#pragma config(Motor,  port2,           FL,            tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           FR,            tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           BL,            tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           BR,            tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           CL,            tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           CCL,           tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           UP,            tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
the robot in tank configuration:
ch2 ch3
2   3

4   5

*/
task main() {
  while (1 == 1){
    //tank tread
    /*
    motor[port2] = vexRT[Ch3];
    motor[port3] = vexRT[Ch2];
    motor[port4] = -vexRT[Ch3];
    motor[port5] = -vexRT[Ch2];
    */
    //a new idea: (make these into macros please ;3)
    int speed;
    //macro concept:
    //calling it: leftgroup(value-from-joystick-and-if-statement);rightgroup(value-from-joystick-and-if-statement);
    void leftgroup(speed){
      motor[port2] = speed;
      motor[port4] = -speed;
    }
    void rightgroup(speed){
      motor[port3] = -speed;
      motor[port5] = speed;
    }
    if (vexRT[Ch1] == 127){ //point turn
      leftgroup(127);
      rightgroup(-127);
      /*
      motor[port2] = 127; //FL
      motor[port4] = -127; //BL
      motor[port3] = -127; //FR
      motor[port5] = 127; //BR */
    } else if (vexRT[Ch1] == -127){ //point turn
      leftgroup(-127);
      rightgroup(127);
      /*
      motor[port2] = -127; //FL
      motor[port4] = 127; //BL
      motor[port3] = -127; //FR
      motor[port5] = 127; //BR */
    } /*else { //differential
      /*macro call:
      leftgroup((vexRT[Ch2] + vexRT[Ch1])/2);
      rightgroup((vexRT[Ch2] - vexRT[Ch1)/2);
      */
      // this code always goes half speed
      /*motor[port2] = (vexRT[Ch2] + vexRT[Ch1]/2)/2; //FL
      motor[port4] = (vexRT[Ch2] + vexRT[Ch1]/2)/2; //BL
      motor[port3] = (vexRT[Ch2] - vexRT[Ch1]/2)/2; //FR
      motor[port5] = (vexRT[Ch2] - vexRT[Ch1]/2)/2; //BR
    }*/
    /*
    old, horribly broken concept
    float powerfactor;
    powerfactor=vexRT[Ch2] / 127;
    motor[port2] = floor(powerfactor * vexRT[Ch1]) + vexRT[Ch1] + vexRT[Ch4];
    motor[port3] = floor(powerfactor * vexRT[Ch1]) + vexRT[Ch1] + vexRT[Ch4];
    motor[port4] = floor(powerfactor * vexRT[Ch1]) + vexRT[Ch1] + vexRT[Ch4];
    motor[port5] = floor(powerfactor * vexRT[Ch1]) + vexRT[Ch1] + vexRT[Ch4];
    */
    //pull
    if (vexRT[Btn6U] == 1){
      motor[port6] = 127;
      motor[port7] = -127;
    }else if (vexRT[Btn6D] == 1){
      motor[port6] = -127;
      motor[port7] = 127;
    }else {
      motor[port6] = 0;
      motor[port7] = 0;
    }
    //up
    if (vexRT[Btn5U] == 1){
      motor[port8] = -127;
    }else if (vexRT[Btn5D] == 1){
      motor[port8] = 127;
    }else {
      motor[port8] = 0;
    }
  }
}
